## Specification
An existing user can sign into their account using their existing login credentials. A new user can create an account by entering their personal information, course details, and personal interests. After signing in, the user will be able to view their profile on the "Home" tab of the page; "Match Pool" shows the matches and profile alongside for the user to select a match; "Sign out" brings the user back to the log-in page. When the matching algorithm runs "Match Pool" will be updated. User credentials are stored and retrieved from a database. The database is extended to allow users to enter up to 2 courses with tutorial section, lecture section, and course code. The database also allows users to enter their year of study and their program of study. 
## Major Design Decisions
- At the end of phase 0, we realised UserManager was doing too much. Hence, we created User, Profile and then stored them into Database. We offload the creation of User and Profile to their respective factories.
- The text database was a good initial database for testing purposes but we needed a more robust and long-term solution. So the Azure Database for SQL replaces the text database.
- We chose to package by component over package by layer because this style of packaging would make it more intuitive to see how groups of classes are intra-related and interrelated.
= We chose to do a Web Application (webapp) over an Android App because of the flexibility of a webapp. A webapp can be accessed on any computer—desktop, laptop and mobile regardless of its OS.
- We chose to use the Spring framework with SpringBoot starters to code the webapp. We chose Spring because it facilitates dependency injection and web app design. We chose SpringBoot because it provides an easy way to manage dependencies and reduces the need for boilerplate code.
- We implemented Builder design pattern.
## SOLID
### Single Responsibility
The CRC cards outline each of the classes and were implemented such that each has a single duty. For example, the user class is only concerned with the user entity that stores all the data pertaining to the user such as the profile, unique identifier, and current matches. The profile class contains the user’s information which includes name, year of study, program of study, courses for a term, interests, and contact information. The responsibility of storing the information in the profile class was not given to the user class in an effort to adhere to this single responsibility principle. The same idea can be extended to the course class containing a course’s code, lecture time, and tutorial time in a separate class from the profile. 
### Open-closed principle
Our design is open for extension because currently, we have not added features like report and chat for users, but we plan to implement those features in Phase 2. Those features can be easily extended without changing the code. It is closed for modification because its basic function, which is matching users, stays the same. 
### Liskov substitution principle
We want to enforce the Liskov substitution principle starting in Phase2. For our project, this principle is demonstrated by the interchangeability of the user and admin classes. Since admin is a child of User, objects of admin should be replaceable by objects in User without breaking the program. Because User and Admin classes are interchangeable, it ensures that Admin adheres to the contact of User to ensure that subclass Admin does not override its superclass in unintended ways. For example, Admin should not modify .setCurrentMatches() and getId() from the User superclass. 
### Interface segregation principle
Vacuously satisfied since we don’t have any interfaces.
### Dependency inversion principle 
CourseRepository implements the JpaRepository interface, which is used by some higher level service to interact with the course database. This implementation is necessary for Spring to auto-generate our repository code. This means that Spring need not worry about the specific type of data the database is working with, so changing the Course class doesn’t impact the repository itself.
## Clean Architecture
The CRC was implemented with a clear design of entities, use cases, interface adapters, and frameworks/drivers. In the center, the entities are separated from the other layers and do not have any knowledge of any of the other classes. When a user interacts with our website, one of the controllers will receive the input from the webpage. It will then call one or more specific use cases depending on the situation. For example, one of the use cases which a controller may use is validating input, and it does that by calling a validator, which implements an interface that all other validators follow.  Another example of clean architecture in our code is our entities classes, like the Course classes do not need to know anything about the controllers and use cases.

The Dependency Rule is followed throughout the code except for the violation mentioned above. A concrete example is the interaction with the UI. The UI only displays information and gets input from the user. After that, the ControlSystem gets the input from the UI and communicates with the Use Cases to carry out functions.
### Scenario Walkthrough Summary:
When a user visits our website, they see step one of registration. The page is templated by Thymeleaf and mapped to an HTML file by the RegistrationController. The controller also specifies what data object to back the form, so that when the user clicks the register button, the filled-in data is sent back to the method. Then, the controller calls a concrete implementation of the Validator interface to validate user input. If the input is valid, the controller directs the request to another url and hands off control to another method. This process repeats for the registration process. Once the user finishes registration, a User object is created by the UserBuilder and passed back to the controller responsible for dashboard interactions. Along the way, various entity objects are also created to represent different kinds of data. In the dashboard, an important action the user can take is look at their matches. This involves sending a list of users to the Matcher class, which is another use case class. Once matching is done, it will return the matching results back to the controller, which stores the data in User objects and displays that information to the actual user through the html. The latter task is mostly delegated to a class called UserPresenter.
## Packaging
For our packaging strategy, we chose to organize our classes according to the components they corresponded to. We chose to package it this way as it would help us in phase 2 when we add the Report classes and Chat functionality. They can be their own packages and not modify any of our current organization.
The component strategy was more intuitive as the relationships between classes were more prominent. Whereas in the layer packaging strategy, these wouldn’t be as apparent and harder to notice. 
However, since we are using Spring as a framework, we may modify our packaging strategy into a hybrid of the layer and component strategy.
## Testing
We’ve tested most of our Java methods. Frontend and Spring framework have their own testing requirements and framework, so we could not adequately test them.
## Refactoring
We added a lot of documentation and design patterns during phase 1 and phase 2.
## Use of GitHub Features
We used the following GitHub features:
- Issues 
	- We used issues to keep track of pending to-dos and bugs as we came across them.
- Actions
	- We used actions in Github Workflows to run the tests every time a commit onto main or pull request to a main was made.
	- It also compiled the code each time and helped us identify compilation errors.
- Pull Requests
	-We used pull requests to ensure code reviews were conducted prior to pushing to main.
	- We also used pull requests to highlight commits that used a design pattern or refactoring.
	- For example, We modified UserManager and introduced User, Profile and CourseSet Factory.
	- We also added documentation for most of phase 0 code.

## Design Patterns
### Factory Design Pattern:[implemented in phase 1]
The factory design pattern is implemented in our project for the classes UserFactory, ProfileFactory and CourseSet Factory. Each of these classes has only 1 method, which is to create and return User, Profile and a set of Courses, respectively.  This reduces the responsibility of UserManager. When we add a new class Admin, we can add an interface that has “createUser()” and create and AdminFactory that implements the interface, so both UserFactory and AdminFactory implement the same interface and create Users or admins
The factory design pattern can also be implemented in our project for the abstract class Report. We currently have two kinds of Reports – HarassmentReport and DistressReport. Both take slightly different information and return different reports. We can create the interface Report with the method “createReport()” and leave the instantiation up to the subclasses.
Now, the HarassmentReport will implement the method “createReport()” and DistressReport will implement the method “createReport()”. Both will return new HarassmentReport() and DistressReport() objects (or products) respectively.
This design pattern is particularly helpful in this case as we can create different types of reports in the future, say ReportUserProfile and not have to worry about changing the implementation of Report. We can create a new subclass and define ReportUserProfile individually.

### Builder Design Pattern: [implemented in phase 2]
We used this to replace the UserManager and ControlSystem. The builder design pattern was used to build User and Profile objects. It implements a number of methods that take in data in the form of POJOs that back the frontend forms, so that, as soon as the user finishes one form, the builder can accept the data and initialize the fields that it can. This is done in successive steps that fit the frontend design. When the user finishes all three forms, the builder creates the final User object which is guaranteed to have all its required fields populated. We chose this pattern because it fits particularly well with the step-oriented design of the frontend. Otherwise, a User object would be too complicated to create just in one go.

### Memento Design Pattern:(Not implemented, future feature)
Currently, we have not implemented Memento as we plan to deploy that for the Chat class in Phase2, but this design pattern is not feasible to implement in Phase1. In Phase2, the users are able to communicate through the chat and the Chat class stores a collection of messages. If, by accident, a user wants to unsend a message, then a Memento can help restore the previous state of the chat conversation. This is useful to implement because in our project, we want to give the user control the ability to ‘undo’. In Phase2, to implement the Memento design pattern for the Chat class, we will need to create the Originator, Memento, and Caretaker objects. The Originator should create a Memento class and use the Memento to capture the current chat state. For example, the originator can have functions such as restoreMessage, createMessagestate. The Memento can have functions such as getMessage, getMessagedate. Then, Caretaker can store all Memento objects in an array so that it can execute rollback to the Originator using saved states from the Memento. The Caretaker may have functions such as Chat.getMessage(), History.add(createMessagestate). In other words, we can keep track of a ‘stack’ of states and activate the rollback feature when needed.
### Decorator Design Pattern:(Not implemented, future feature)
In the project, currently we have an entity class called Message. It represents a single message in a chat. Each instance of Message contains information about the content of the message, who sent the message and the time/date of the message. This message needs to be represented in our GUI somehow. Here, we can use the decorator pattern. We can have MessageGUI as an interface with a method signature draw(). Message can implement MessageGUI and implement the draw method and provide a basic transparent box with the content of the message displayed in black inside the box. In addition, we can have multiple decorators such as MessageBorder and MessageFillColour that can wrap around an instance of Message to provide additional functionalities to the instance at runtime. 

These functionalities could include creating a border around the basic white box in the chat or to change the fill colour of the box. The way this would be programmed is that the decorators like MessageBorder and MessageFillColour would be subclasses to the BaseDecorator that implements MessageGUI. The BaseDecorator would take an instance of Message as a parameter. In this way, we can add additional display features to each instance of Message at runtime without changing the class Message itself. This will allow easy customisation of the aesthetics of messages. Each user of our app can thus change how their messages look in their chats in their app as per their wishes.

## Progress Report
Thus far, our group has diligently worked on implementing phase 1 of this project. The app was implemented as a webapp using Spring. Adrian used the designs from Phase 0 to create the webapp structure using HTML, CSS, and JavaScript. The backend team (Tony, Akshat, Rue  and Dien) built upon the existing skeleton code in coding the additional classes that were not implemented before and implemented the database. Lawrence helped to create the design document and UML.
### Summary of each member’s progress
* **Adrian:** [phase 1]
For Phase 1, I was responsible for front-end development and wrote some test cases. I designed all the screens for the webapp, such as the welcome page, create an account & sign-in page, user’s account page, socials page, and finally the matching screens. To present to the user functionalities that we wanted to implement, such as the matching algorithm and log-in account functions, we decided that a webapp is better than making a mobile app we originally planned in Phase0. I enjoy the simple mobile app design from Phase0 and did my best to extend that theme to the webapp.  I also wrote test cases for entity User and Course; made local branches to edit code, used pull requests, raised issues, and approved pull requests to work with the team. One aspect of the front-end design that has worked well is the ease of use for the user and code organization. Connecting frontend code to the backend is still work in progress and will take a bit more time, but much of it has been completed. 
[new in phase 2]
	I was responsible for front-end development and wrote some test cases. I made improvements to some screens for the web app, such as the main dashboard page, socials page, and matching screens, and created an error page.  I also wrote test cases for entity User and Course; made local branches to edit code, used pull requests, raised issues, and approved pull requests to work with the team. A lot of progress has been made but I have been trying to work with Tony to connect the HTML code to the backend.
This is one of the pull requests that I had a significant contribution to:
https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/5 
* **Dien:** I built upon the existing skeleton code by adding methods to allow users to edit their profiles. I also implemented the Factory design pattern after discussing with the team what would be a suitable design pattern to use. Creating the class diagrams helped me understand the structure of our whole project and how the classes interact with each other. This made implementing the Factory design pattern easier. The new Factory classes made the code cleaner and easier to fix if there were any bugs in the process of creating a User. It also lessens the responsibility of UserManager. I wrote test cases for the Factory classes, however I wasn’t able to write tests for methods that edit profiles in UserManager because we haven’t finished implementing the database. Rue and I tried to link Spring Boot with HTML using Thymeleaf so Tony had to help us. While writing methods to create Users and Profiles in UserManager, Adrian and I did not communicate, so the information to be input in the Java class did not match with the information to be input in the UI. In Phase 2, I will communicate with frontend more and make sure the whole team finalizes each screen.
In Phase 2, I fixed the matching algorithm that Akshat wrote in Phase 0. Previously, it did not have a maximum number of matches per person, only a soft limit. So when it was a user’s turn to be matched, they could have only 2 matches, but when it was other people’s turns to be matched, an unlimited number of matches could be added to that user’s match pool. I wanted to add a limit to the number of matches, and also have them be in each other’s top 4 matches (based on match metric). As of now, the matching algorithm works when we have a small number of users. I am unsure how well it will perform with a large number of users, like 1000 or more. In Phase 2, I communicated with the front-end team a lot more effectively, hence taking top 4 matches instead of a different number. 
Pull requests: 
https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/19 - Implement Factory design
https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/44 - Fix matching algorithm

* **Akshat:** I along with Tony set up the Microsoft Azure server which currently hosts our entire codebase and also runs our web application. In addition, I set up the Azure Database for MySQL which is meant to replace our text database from Phase 0 (PR #28 - https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/28 and #37 - https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/37 are one of the most significant). Currently, it is able to store courses that are inputted as part of registering one’s courses. While it is unable to store Users and Profiles at the moment, this is a good proof-of-concept that showcases the functionality of the database as well as the interaction between the frontend and the database. After consulting with Rue, Dien and Tony, I repackaged all the java classes into components to have a more intuitive packaging strategy rather than just having all classes in one package. 
	In Phase 2, I spent 20+ hours trying to switch Azure MySQL to Azure CosmosDB (NoSQL). While I had some success, due to outdated, insufficient and inconsistent documentation I was unable to completely switch to Azure CosmosDB. After that, I helped Tony with Spring Boot and Thymeleaf to hook up Frontend with Backend (specifically the Matching Screen) (refer PR #45- https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/45).

* **Rue:** [Phase 1 progress]
	Continuing with our designs from Phase 0, I helped Adrian modify the mobile designs into a web app design. I was involved in deciding what design pattern to use, the implementation of the design pattern, packaging strategy and the MySQL database. I also helped test the UserFactory and CourseSetFactory (Pull request link 27 - https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/27) and refactor our code to include documentation (Pull request link 29 - https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/29). I worked with Dien and Tony to link SpringBoot and Thymeleaf. I also helped create the design document.

[Phase 2 progress]
In phase 2, I helped refactor the existing code to ensure Tony could include the Builder design pattern. I modified the existing User and Profile classes. (Pull request link 42 -https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/42 and Pull request link 43 - https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/43/) I also helped Dien bounce ideas to improve our matching algorithm’s efficiency. Furthermore, I helped create the accessibility report and modify the design document for Phase 2.
* **Tony:** I worked with Akshat to set up the Microsoft Azure server.  I also worked with the Spring framework and SpringBoot and attempted to integrate the front- and backend. Specifically, I modified the HTML files by adding Thymeleaf (the template engine of our choice) annotations and wrote and annotated Java classes used by Spring. However, the complexity of our project means that there are many unfinished parts. I list some of them here:
	- The majority of the frontend is still disconnected from the backend.
	- Too much is hard coded into the HTML right now (e.g. variable names, etc.). This needs to be fixed by introducing application properties.
	- The HTML is still messy, primarily because it is filled with Webflow related markups that we don’t need in our project.
	- Code for validating forms is not done.
etc.
I will continue working on Spring for project phase 2 and hopefully address some of the leftover problems from this phase. Also, like I have done always, I will continue to help my teammates solve problems.

(NEW in Phase 2)
	In Phase 2, I continued working with the Spring framework to integrate the front end and the backend. I worked with my teammates to connect the registration pages (three in total) to validation logic through the interface that Spring provides, and I also used Thymeleaf as the template engine for retrieving form data and storing them in POJOs, which are later converted to User objects using a Builder class that I implemented. For the main (dashboard) screen, I designed and implemented a Presenter object which is responsible for populating model objects, which store attributes that in turn populate fields in the rendered webpage. Using this pattern, I integrated the dashboard and matching screen with the backend as well (with help from Akshat).
	As an excursion, I helped Akshat troubleshoot his code with CosmosDB.
	A significant pull request I worked on in Phase 2 is #41 (https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/41). Firstly, this pull request fixed Issue #34(https://github.com/CSC207-UofT/course-project-super-turtle-hackers/issues/34), which would otherwise mess up how we store course information in users. Secondly, the bulk of the validation logic was included in this pull request alone, without which our Phase 2 wouldn’t be that much different from Phase 1 at all. 
	
* **Lawrence:** 
I finished the matching algorithm (pull request 40) so that it would account for the user’s program of study and year of study. I created an optimized mathematical model that allows for users to be optimally matched with other users. I also created several methods that allow for 1000s of misspelt inputs and still be able to use the app. I also made test cases for matcher as well as for other classes such as user, courseset factory, and user manager. I added docstrings and fixed bugs to multiple classes. I also worked on this design document’s specifications and scenario walkthrough. 
Pull request: https://github.com/CSC207-UofT/course-project-super-turtle-hackers/pull/40 



### Open questions your group is struggling with
We are currently trying to decide how to store our data in our database and ensure we’re following Clean Architecture as we do so.
We are also trying to figure out how to implement the Chat functionality. We also struggled with implementing our database.

### What has worked well so far with your design?
Entity and use case classes follow Clean Architecture and work well with each other teo create and edit users and user profiles. We have refactored many parts of the design, such as adding UserFactory without having to change any entities (User, Profile, Course) or ControlSystem.
We used Springboot’s decorators and simplified our code a lot for the azure database. We did not need to write MySQL commands since the decorators automatically handled that for us.

